# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.

import os
from typing import cast
from unittest import TestCase

from cdm.enums import CdmObjectType
from cdm.objectmodel import CdmEntityDefinition, CdmAttributeContext, CdmAttributeReference, \
    CdmArgumentDefinition, CdmTraitReference, CdmCollection, CdmAttributeItem, CdmAttributeGroupDefinition, \
    CdmTraitCollection
from tests.common import TestHelper


class AttributeContextUtil:
    """
    Multiple test classes in projections test the attribute context tree generated for various scenarios.
    This utility class helps generate the actual attribute context generated by the scenario, so that it can be compared with expected attribute context tree.
    This also handles the validation of the expected vs. actual attribute context.
    """
    def __init__(self):
        # This string is used to concatenate all the attribute contexts and traits of an entity into one string
        # so that we can compare it to the expected output txt file.
        self._bldr = ''

    def get_attribute_context_strings(self, resolved_entity: 'CdmEntityDefinition') -> str:
        """Function to get the attribute context string tree from a resolved entity"""

        # clear the string builder
        self._bldr = ''

        # get the corpus path for each attribute context in the tree
        self._get_content_declared_path(resolved_entity.attribute_context)

        # get the traits for all the attributes of a resolved entity
        self._get_traits(resolved_entity.attributes)

        return self._bldr

    def get_argument_values_as_strings(self, args: 'CdmArgumentDefinition') -> str:
        # clear the string builder
        self._bldr = ''

        # get the corpus path for each attribute context in the tree
        self._get_argument_values(args)

        return self._bldr

    def _get_content_declared_path(self, attrib_context: 'CdmAttributeContext') -> None:
        """Get the corpus path for each attribute context in the tree and build a string collection that we can
        compare with the expected attribute context corpus path collection."""
        if attrib_context and attrib_context.contents and len(attrib_context.contents) > 0:
            for i in range(len(attrib_context.contents)):
                content = attrib_context.contents[i]
                self._bldr += content.at_corpus_path
                self._bldr += '\n'

                if not isinstance(content, CdmAttributeReference):
                    self._get_content_declared_path(content)

    def _get_traits(self, attributes: 'CdmCollection[CdmAttributeItem]') -> None:
        """Get the traits for all the attributes of a resolved entity"""
        for attrib in attributes:
            attrib_corpus_path = attrib.at_corpus_path
            self._bldr += attrib_corpus_path
            self._bldr += '\n'

            from cdm.objectmodel import CdmAttributeGroupReference

            if isinstance(attrib, CdmAttributeGroupReference):
                att_group_def = cast(CdmAttributeGroupReference, attrib).explicit_reference  # type: CdmAttributeGroupDefinition
                self._bldr += att_group_def.at_corpus_path
                self._bldr += '\n'
                self._get_trait_collection(att_group_def.exhibits_traits)
                self._get_traits(att_group_def.members)
            else:
                self._get_trait_collection(attrib.applied_traits)

    def _get_trait_collection(self, trait_collection: 'CdmTraitCollection') -> None:
            for trait in trait_collection:
                attrib_traits = trait.named_reference
                self._bldr += attrib_traits
                self._bldr += '\n'

                if isinstance(trait, CdmTraitReference):
                    for args in trait.arguments:
                        self._get_argument_values(args)

    def _get_argument_values(self, args: 'CdmArgumentDefinition') -> None:
        param_name = args._resolved_parameter.name if args._resolved_parameter else None
        param_default_value = args._resolved_parameter.default_value if args._resolved_parameter else None

        if param_name or param_default_value:
            self._bldr += '  [Parameter (Name / DefaultValue): {} / {}]'.format(param_name if param_name else '', param_default_value if param_default_value else '')
            self._bldr += '\n'

        if isinstance(args.value, str):
            args_value = args.value
            if args_value:
                self._bldr += '  [Argument Value: {}]'.format(args_value)
                self._bldr += '\n'
        elif args.value.simple_named_reference == True if args.value else False:
            args_value = args.value.named_reference
            if args_value:
                self._bldr += '  [Argument Value: {}]'.format(args_value)
                self._bldr += '\n'
        elif args.value.explicit_reference.object_type == CdmObjectType.CONSTANT_ENTITY_DEF if args.value else False:
            const_ent = args.value.explicit_reference
            if const_ent:
                refs = []
                for val in const_ent.constant_values:
                    self._bldr += '  [Argument Value: {}]'.format(','.join(val))
                    self._bldr += '\n'

    @staticmethod
    async def validate_attribute_context(test: 'TestCase', expected_output_path: str, entity_name: str, resolved_entity: 'CdmEntityDefinition', update_expected_output: bool = False) -> None:
        """A function to validate if the attribute context tree & traits generated for a resolved entity is the same
        as the expected and saved attribute context tree & traits for a test case"""
        if resolved_entity.attribute_context:
            attr_ctx_util = AttributeContextUtil()

            # Actual
            actual_file_path = os.path.join(expected_output_path.replace('ExpectedOutput', TestHelper.get_test_actual_output_folder_name()), 'AttrCtx_{}.txt'.format(entity_name))

            # Save Actual AttrCtx_*.txt and Resolved_*.cdm.json
            actual_text = attr_ctx_util.get_attribute_context_strings(resolved_entity)
            with open(actual_file_path, 'w') as actual_attr_ctx_file:
                actual_attr_ctx_file.write(actual_text)
            await resolved_entity.in_document.save_as_async('Resolved_{}.cdm.json'.format(entity_name), False)

            # Expected
            expected_file_path = os.path.join(expected_output_path, 'AttrCtx_{}.txt'.format(entity_name))
            if update_expected_output:
                with open(expected_file_path, 'w') as expected_attr_ctx_file:
                    expected_attr_ctx_file.write(actual_text)

            with open(expected_file_path) as expected_file:
                expected_text = expected_file.read()

            # Test if Actual is Equal to Expected
            test.assertEqual(expected_text.replace('\r\n', '\n'), actual_text.replace('\r\n', '\n'))
